"""Export and delivery utilities for compliance reports."""

import os
import smtplib
import requests
from pathlib import Path
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders
from datetime import datetime

from src.config.settings import OUTPUT_DIR


def export_to_pdf(markdown_path: str = None, output_path: str = None) -> str:
    """
    Convert markdown report to PDF.
    
    Args:
        markdown_path: Path to markdown file (default: output/compliance_report.md)
        output_path: Path for PDF output (default: output/compliance_report.pdf)
    
    Returns:
        Path to generated PDF
    """
    try:
        from markdown import markdown
        from weasyprint import HTML, CSS
    except ImportError:
        raise ImportError(
            "PDF export requires: pip install markdown weasyprint\n"
            "On Mac, also run: brew install pango"
        )
    
    markdown_path = markdown_path or OUTPUT_DIR / "compliance_report.md"
    output_path = output_path or OUTPUT_DIR / "compliance_report.pdf"
    
    # Read markdown
    with open(markdown_path, "r", encoding="utf-8") as f:
        md_content = f.read()
    
    # Convert to HTML
    html_content = markdown(md_content, extensions=['tables', 'fenced_code'])
    
    # Add styling
    styled_html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <style>
            body {{
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                line-height: 1.6;
                max-width: 800px;
                margin: 40px auto;
                padding: 20px;
                color: #333;
            }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }}
            h2 {{ color: #34495e; margin-top: 30px; }}
            h3 {{ color: #7f8c8d; }}
            table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
            th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
            th {{ background-color: #3498db; color: white; }}
            tr:nth-child(even) {{ background-color: #f9f9f9; }}
            code {{ background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }}
            pre {{ background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }}
            .header {{ text-align: center; margin-bottom: 40px; }}
            .footer {{ margin-top: 40px; text-align: center; color: #7f8c8d; font-size: 12px; }}
        </style>
    </head>
    <body>
        <div class="header">
            <h1>üîç Compliance Analysis Report</h1>
            <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}</p>
        </div>
        {html_content}
        <div class="footer">
            <p>Generated by Policy Documents Agentic AI Application</p>
        </div>
    </body>
    </html>
    """
    
    # Convert to PDF
    HTML(string=styled_html).write_pdf(output_path)
    
    return str(output_path)


def send_to_telegram(
    file_path: str,
    bot_token: str = None,
    chat_id: str = None,
    caption: str = "üìã Compliance Report"
) -> bool:
    """
    Send file to Telegram.
    
    Args:
        file_path: Path to file to send
        bot_token: Telegram bot token (or set TELEGRAM_BOT_TOKEN env var)
        chat_id: Telegram chat ID (or set TELEGRAM_CHAT_ID env var)
        caption: Message caption
    
    Returns:
        True if successful
    """
    bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = chat_id or os.getenv("TELEGRAM_CHAT_ID")
    
    if not bot_token or not chat_id:
        raise ValueError(
            "Telegram credentials required. Set TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID in .env"
        )
    
    url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
    
    with open(file_path, "rb") as f:
        response = requests.post(
            url,
            data={"chat_id": chat_id, "caption": caption},
            files={"document": f}
        )
    
    if response.status_code == 200:
        print(f"‚úÖ Report sent to Telegram!")
        return True
    else:
        print(f"‚ùå Telegram send failed: {response.text}")
        return False


def send_to_email(
    file_path: str,
    to_email: str = None,
    subject: str = "üìã Compliance Analysis Report",
    body: str = "Please find attached the compliance analysis report.",
    smtp_server: str = None,
    smtp_port: int = 587,
    smtp_user: str = None,
    smtp_password: str = None,
) -> bool:
    """
    Send file via email.
    
    Args:
        file_path: Path to file to attach
        to_email: Recipient email (or set REPORT_EMAIL env var)
        subject: Email subject
        body: Email body
        smtp_server: SMTP server (or set SMTP_SERVER env var)
        smtp_port: SMTP port (default 587)
        smtp_user: SMTP username (or set SMTP_USER env var)
        smtp_password: SMTP password (or set SMTP_PASSWORD env var)
    
    Returns:
        True if successful
    """
    to_email = to_email or os.getenv("REPORT_EMAIL")
    smtp_server = smtp_server or os.getenv("SMTP_SERVER", "smtp.gmail.com")
    smtp_user = smtp_user or os.getenv("SMTP_USER")
    smtp_password = smtp_password or os.getenv("SMTP_PASSWORD")
    
    if not all([to_email, smtp_user, smtp_password]):
        raise ValueError(
            "Email credentials required. Set REPORT_EMAIL, SMTP_USER, SMTP_PASSWORD in .env"
        )
    
    # Create message
    msg = MIMEMultipart()
    msg['From'] = smtp_user
    msg['To'] = to_email
    msg['Subject'] = subject
    
    msg.attach(MIMEText(body, 'plain'))
    
    # Attach file
    with open(file_path, "rb") as f:
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(f.read())
        encoders.encode_base64(part)
        part.add_header(
            'Content-Disposition',
            f'attachment; filename="{Path(file_path).name}"'
        )
        msg.attach(part)
    
    # Send
    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_password)
            server.send_message(msg)
        print(f"‚úÖ Report sent to {to_email}!")
        return True
    except Exception as e:
        print(f"‚ùå Email send failed: {e}")
        return False
